// Copyright (c) 2019, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package etensor

import (
	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/memory"
	"github.com/apache/arrow/go/arrow/tensor"
	"github.com/emer/emergent/bitslice"
)

{{range .In}}

// {{.Name}} is an n-dim array of {{.Type}}s.
type {{.Name}} struct {
	Shape
	Values []{{.Type}}
	Nulls bitslice.Slice
}

// New{{.Name}} returns a new n-dimensional array of {{.Type}}s.
// If strides is nil, row-major strides will be inferred.
// If names is nil, a slice of empty strings will be created.
// Nulls are initialized to nil.
func New{{.Name}}(shape, strides []int, names []string) *{{.Name}} {
	tsr := &{{.Name}}{}
	tsr.SetShape(shape, strides, names)
	tsr.Values = make([]{{or .Type}}, tsr.Len())
	return tsr
}

// New{{.Name}}Shape returns a new n-dimensional array of {{.Type}}s.
// Using shape structure instead of separate data.
// Nulls are initialized to nil.
func New{{.Name}}Shape(shape *Shape) *{{.Name}} {
	tsr := &{{.Name}}{}
	tsr.CopyShape(shape)
	tsr.Values = make([]{{or .Type}}, tsr.Len())
	return tsr
}

func (tsr *{{.Name}}) Value(i []int)  {{or .Type}} { j := tsr.Offset(i); return tsr.Values[j] }
func (tsr *{{.Name}}) Set(i []int, val {{or .Type}})  { j := tsr.Offset(i); tsr.Values[j] = val }
func (tsr *{{.Name}}) IsNull(i []int) bool {
	if tsr.Nulls == nil {
		return false
	}
	j := tsr.Offset(i)
	return tsr.Nulls.Index(j)
}
func (tsr *{{.Name}}) SetNull(i []int, nul bool) {
	if tsr.Nulls == nil {
		tsr.Nulls = bitslice.Make(tsr.Len(), 0)
	}
	j := tsr.Offset(i)
	tsr.Nulls.Set(j, nul)
}

// Clone creates a new tensor that is a copy of the existing tensor, with its own
// separate memory -- changes to the clone will not affect the source.
func (tsr *{{.Name}}) Clone() *{{.Name}} {
	csr := New{{.Name}}Shape(&tsr.Shape)
	copy(csr.Values, tsr.Values)
	if tsr.Nulls != nil {
		csr.Nulls = tsr.Nulls.Clone()
	}
	return csr
}

// SubSlice returns a new tensor as a sub-slice of the current one, incorporating the given number
// of dimensions (0 < subdim < NumDims of this tensor).  Only valid for row or column major layouts.
// subdim are the inner, contiguous dimensions (i.e., the final dims in RowMajor and the first ones in ColMajor).
// offs are offsets for the outer dimensions (len = NDims - subdim) for the subslice to return.
// The new tensor points to the values of the this tensor (i.e., modifications will affect both).
// Use Clone() method to separate the two.
// todo: not getting nulls yet.
func (tsr *{{.Name}}) SubSlice(subdim int, offs []int) (*{{.Name}}, error) {
	nd := tsr.NumDims()
	od := nd - subdim
	if od <= 0 {
		return nil, errors.New("SubSlice number of sub dimensions was >= NumDims -- must be less")
	}
	if tsr.IsRowMajor() {
		stsr := &{{.Name}}{}
		stsr.SetShape(tsr.shape[od:], nil, tsr.names[od:]) // row major def
		sti := make([]int, nd)
		copy(sti, offs)
		stoff := tsr.Offset(sti)
		stsr.Values = tsr.Values[stoff:]
		return stsr, nil
	} else if tsr.IsColMajor() {
		stsr := &{{.Name}}{}
		stsr.SetShape(tsr.shape[:subdim], nil, tsr.names[:subdim])
		stsr.strides = ColMajorStrides(stsr.shape)
		sti := make([]int, nd)
		for i := subdim; i < nd; i++ {
			sti[i] = offs[i-subdim]
		}
		stoff := tsr.Offset(sti)
		stsr.Values = tsr.Values[stoff:]
		return stsr, nil
	}
	return nil, errors.New("SubSlice only valid for RowMajor or ColMajor tensors")
}

// ToArrow returns the apache arrow equivalent of the tensor
func (tsr *{{.Name}}) ToArrow() *tensor.{{.Name}} {
	bld := array.New{{.Name}}Builder(memory.DefaultAllocator)
	if tsr.Nulls != nil {
		bld.AppendValues(tsr.Values, tsr.Nulls.ToBools())
	} else {
		bld.AppendValues(tsr.Values, nil)
	}
	vec := bld.New{{.Name}}Array()
	return tensor.New{{.Name}}(vec.Data(), tsr.Shape64(), tsr.Strides64(), tsr.DimNames())
}

// FromArrow intializes this tensor from an arrow tensor of same type
// cpy = true means make a copy of the arrow data, otherwise it directly
// refers to its values slice -- we do not Retain() on that data so it is up
// to the go GC and / or your own memory management policies to ensure the data
// remains intact!
func (tsr *{{.Name}}) FromArrow(arw *tensor.{{.Name}}, cpy bool) {
	nms := make([]string, arw.NumDims()) // todo: would be nice if it exposed DimNames()
	for i := range nms {
		nms[i] = arw.DimName(i)
	}
	tsr.SetShape64(arw.Shape(), arw.Strides(), nms)
	if cpy {
		vls := arw.{{.Name}}Values()
		tsr.Values = make([]{{or .Type}}, tsr.Len())
		copy(tsr.Values, vls)
	} else {
		tsr.Values = arw.{{.Name}}Values()
	}
	// todo: doesn't look like the Data() exposes the nulls themselves so it is not
	// clear we can copy the null values -- nor does it seem that the tensor class
	// exposes it either!  https://github.com/apache/arrow/issues/3496
	// nln := arw.Data().NullN()
	// if nln > 0 {
	// }
}


{{- end}}


