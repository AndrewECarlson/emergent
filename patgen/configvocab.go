// Copyright (c) 2019, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package patgen

import (
	"fmt"
	"log"
	"math"
	"math/rand"

	"github.com/emer/etable/etensor"
)

type Vocab map[string]*etensor.Float32

// AddVocabEmpty adds an empty pool to the vocabulary. This then can be used to make Input patterns in test trials.
func AddVocabEmpty(mp Vocab, rows, poolY, poolX int, poolName string) {
	tsr := etensor.NewFloat32([]int{rows, poolY, poolX}, nil, []string{"row", "Y", "X"})
	mp[poolName] = tsr
}

// AddVocabPermutedBinary adds a permuted binary pool to the vocabulary. This could be used to make different permuted binary patterns (with pctAct percent bits turned on) for a pool.
func AddVocabPermutedBinary(mp Vocab, rows, poolY, poolX int, pctAct float32, poolName string) {
	nOn := int(math.Round(float64(poolY) * float64(poolX) * float64(pctAct)))
	tsr := etensor.NewFloat32([]int{rows, poolY, poolX}, nil, []string{"row", "Y", "X"})
	PermutedBinaryRows(tsr, nOn, 1, 0)
	mp[poolName] = tsr
}

// AddVocabRepeat adds a repeated pool (with pctAct percent bits turned on) to the vocabulary.
func AddVocabRepeat(mp Vocab, rows, poolY, poolX int, pctAct float32, poolName string) {
	AddVocabPermutedBinary(mp, 1, poolY, poolX, pctAct, poolName)
	VocabRepeat(mp, poolName, rows)
}

// VocabRepeat repeats a pool rpt times (when rpt==1, nothing happens).
func VocabRepeat(mp Vocab, poolName string, rpt int) {
	mp["tmp"] = mp[poolName]
	for i := 0; i < rpt-1; i++ {
		VocabConcat(mp, poolName, []string{poolName, "tmp"})
	}
	delete(mp, "tmp")
}

// AddVocabDrift adds a row-by-row drifted pool to the vocabulary, starting from the first row pattern (with pctAct percent bits turned on).
// The current row patterns will be generated by taking the previous row pattern and flipping pctDrift percent of active bits.
func AddVocabDrift(mp Vocab, rows, poolY, poolX int, pctAct, pctDrift float32, poolName string) {
	nOn := int(math.Round(float64(poolY) * float64(poolX) * float64(pctAct)))
	nDrift := int(math.Round(float64(nOn) * float64(pctDrift)))
	AddVocabPermutedBinary(mp, rows, poolY, poolX, pctAct, poolName)
	VocabDrift(mp, nDrift, poolName)
}

// VocabDrift makes a pool in the vocabulary row-by-row drifted, starting from the first row pattern (with pctAct percent bits turned on).
// The current row patterns will be generated by taking the previous row pattern and flipping nDrift bits.
func VocabDrift(mp Vocab, nDrift int, poolName string) {
	tsr := mp[poolName]
	rows := tsr.Shapes()[0]
	for i := 0; i < rows; i++ {
		subtsr := tsr.SubSpace([]int{i})
		if i > 0 {
			subtsr.CopyFrom(tsr.SubSpace([]int{i - 1}))
			FlipBits(subtsr, nDrift, nDrift, 1, 0)
		}
	}
}

// VocabClone clones an old pool in the vocabulary and make it a new one.
func VocabClone(mp Vocab, frmPool, toNewPool string) {
	mp[toNewPool] = mp[frmPool].Clone().(*etensor.Float32)
}

// VocabShuffle shuffles a pool in the vocabulary on its first dimension (row).
func VocabShuffle(mp Vocab, shufflePools []string) {
	for _, key := range shufflePools {
		tsr := mp[key]
		rows := tsr.Shapes()[0]
		poolY := tsr.Shapes()[1]
		poolX := tsr.Shapes()[2]
		sRows := rand.Perm(rows)
		sTsr := etensor.NewFloat32([]int{rows, poolY, poolX}, nil, []string{"row", "Y", "X"})
		for iRow, sRow := range sRows {
			sTsr.SubSpace([]int{iRow}).CopyFrom(tsr.SubSpace([]int{sRow}))
		}
		mp[key] = sTsr
	}
}

// VocabConcat contatenates several pools in the vocabulary and store it into newPool (could be one of the previous pools).
func VocabConcat(mp Vocab, newPool string, frmPools []string) error {
	tsr := mp[frmPools[0]].Clone().(*etensor.Float32)
	for i, key := range frmPools {
		if i > 0 {
			// check pool shape
			if !(tsr.SubSpace([]int{0}).(*etensor.Float32).Shape.IsEqual(&mp[key].SubSpace([]int{0}).(*etensor.Float32).Shape)) {
				err := fmt.Errorf("shapes of input pools must be the same") // how do I stop the program?
				log.Println(err.Error())
				return err
			}

			currows := tsr.Shapes()[0]
			approws := mp[key].Shapes()[0]
			tsr.SetShape([]int{currows + approws, tsr.Shapes()[1], tsr.Shapes()[2]}, nil, []string{"row", "Y", "X"})
			for iRow := 0; iRow < approws; iRow++ {
				subtsr := tsr.SubSpace([]int{iRow + currows})
				subtsr.CopyFrom(mp[key].SubSpace([]int{iRow}))
			}
		}
	}
	mp[newPool] = tsr
	return nil
}

// VocabSlice slices a pool in the vocabulary into new ones.
// SliceOffs is the cutoff points in the original pool, should have one more element than newPools.
func VocabSlice(mp Vocab, frmPool string, newPools []string, sliceOffs []int) error {
	oriTsr := mp[frmPool]
	poolY := oriTsr.Shapes()[1]
	poolX := oriTsr.Shapes()[2]

	// check newPools and sliceOffs have same length
	if len(newPools)+1 != len(sliceOffs) {
		err := fmt.Errorf("sliceOffs should have one more element than newPools") // how do I stop the program?
		log.Println(err.Error())
		return err
	}

	// check sliceOffs is in right order
	preVal := sliceOffs[0]
	for i, curVal := range sliceOffs {
		if i > 0 {
			if preVal < curVal {
				preVal = curVal
			} else {
				err := fmt.Errorf("sliceOffs should increase progressively") // how do I stop the program?
				log.Println(err.Error())
				return err
			}
		}
	}

	// slice
	frmOff := sliceOffs[0]
	for i := range newPools {
		toOff := sliceOffs[i+1]
		newPool := newPools[i]
		newTsr := etensor.NewFloat32([]int{toOff - frmOff, poolY, poolX}, nil, []string{"row", "Y", "X"})
		for off := frmOff; off < toOff; off++ {
			newTsr.SubSpace([]int{off - frmOff}).CopyFrom(oriTsr.SubSpace([]int{off}))
		}
		mp[newPool] = newTsr
		frmOff = toOff
	}
	return nil
}
